üåê Configura√ß√£o de CORS no ASP.NET Core 8
Este guia detalha como configurar CORS (Cross-Origin Resource Sharing) em uma Web API ASP.NET Core 8 para permitir acesso seguro de frontends hospedados em dom√≠nios diferentes (ex.: Angular em http://localhost:4200). O c√≥digo √© comentado, integr√°vel com autentica√ß√£o JWT (dos resumos anteriores), e formatado para renderiza√ß√£o correta no GitHub.
üìò √çndice

O que √© CORS?
Pacotes Necess√°rios
Configura√ß√£o B√°sica de CORS
Configura√ß√£o Avan√ßada com Pol√≠ticas
Integra√ß√£o com Autentica√ß√£o
Solu√ß√£o de Problemas Comuns
Boas Pr√°ticas e Seguran√ßa
Exemplo de Frontend (Opcional)


1. ‚ùì O que √© CORS?
CORS √© um mecanismo de seguran√ßa do navegador que controla quais origens (dom√≠nios) podem acessar recursos de uma API hospedada em outro dom√≠nio. Por exemplo:

Sua API roda em https://localhost:5001.
Seu frontend Angular roda em http://localhost:4200.
Sem CORS, o navegador bloquear√° requisi√ß√µes do frontend para a API devido √† pol√≠tica de mesma origem (same-origin policy).

Este guia configura CORS para permitir essas requisi√ß√µes de forma segura.

2. üì¶ Pacotes Necess√°rios
Nenhum pacote adicional √© necess√°rio para CORS no ASP.NET Core 8, pois o suporte est√° embutido no framework. Se voc√™ est√° usando os resumos anteriores (autentica√ß√£o, 2FA, etc.), j√° tem os pacotes relevantes:
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer

Explica√ß√£o:  

CORS √© configurado via middleware nativo do ASP.NET Core (UseCors).  
Pacotes como JwtBearer s√£o usados para proteger endpoints, e CORS deve permitir cabe√ßalhos como Authorization.


3. ‚öôÔ∏è Configura√ß√£o B√°sica de CORS
Configure CORS no Program.cs para permitir acesso de uma origem espec√≠fica.
var builder = WebApplication.CreateBuilder(args);

// Configura CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins("http://localhost:4200") // Permite apenas o frontend Angular
              .AllowAnyMethod() // Permite GET, POST, etc.
              .AllowAnyHeader() // Permite cabe√ßalhos como Authorization
              .AllowCredentials(); // Permite cookies e credenciais (ex.: JWT)
    });
});

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseCors("AllowFrontend"); // Aplica a pol√≠tica CORS
app.UseAuthentication(); // Se usar autentica√ß√£o (ex.: JWT)
app.UseAuthorization();
app.MapControllers();

app.Run();

Explica√ß√£o:  

AddCors: Registra o servi√ßo CORS com uma pol√≠tica chamada AllowFrontend.  
WithOrigins: Especifica o dom√≠nio do frontend (ex.: http://localhost:4200 para Angular).  
AllowAnyMethod: Permite todos os m√©todos HTTP (GET, POST, PUT, etc.).  
AllowAnyHeader: Permite cabe√ßalhos como Authorization (essencial para JWT).  
AllowCredentials: Habilita envio de credenciais (ex.: cookies ou tokens).  
UseCors: Aplica a pol√≠tica ao pipeline, antes de autentica√ß√£o e autoriza√ß√£o.


4. üîß Configura√ß√£o Avan√ßada com Pol√≠ticas
Para maior controle, crie pol√≠ticas espec√≠ficas para diferentes cen√°rios (ex.: endpoints p√∫blicos vs. protegidos).
var builder = WebApplication.CreateBuilder(args);

// Configura m√∫ltiplas pol√≠ticas CORS
builder.Services.AddCors(options =>
{
    // Pol√≠tica para endpoints p√∫blicos
    options.AddPolicy("AllowAnyOrigin", policy =>
    {
        policy.AllowAnyOrigin() // Qualquer origem pode acessar
              .AllowAnyMethod()
              .AllowAnyHeader();
    });

    // Pol√≠tica para endpoints autenticados
    options.AddPolicy("AllowFrontendAuth", policy =>
    {
        policy.WithOrigins(
                "http://localhost:4200", // Angular local
                "https://meufrontend.com" // Frontend em produ√ß√£o
              )
              .WithMethods("GET", "POST", "PUT") // Apenas m√©todos espec√≠ficos
              .WithHeaders("Authorization", "Content-Type") // Apenas cabe√ßalhos necess√°rios
              .AllowCredentials(); // Suporta JWT
    });
});

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseCors(); // Aplica CORS globalmente (usar√° pol√≠ticas espec√≠ficas nos controllers)
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();

Aplicando Pol√≠ticas nos Controllers
Use o atributo [EnableCors] para aplicar pol√≠ticas espec√≠ficas:
[ApiController]
[Route("api/public")]
public class PublicController : ControllerBase
{
    // Endpoint p√∫blico acess√≠vel por qualquer origem
    [HttpGet("info")]
    [EnableCors("AllowAnyOrigin")]
    public IActionResult GetInfo()
    {
        return Ok("Informa√ß√£o p√∫blica.");
    }
}

[ApiController]
[Route("api/protected")]
public class ProtectedController : ControllerBase
{
    // Endpoint protegido acess√≠vel apenas pelo frontend autorizado
    [HttpGet("data")]
    [Authorize]
    [EnableCors("AllowFrontendAuth")]
    public IActionResult GetData()
    {
        return Ok("Dados protegidos.");
    }
}

Explica√ß√£o:  

AllowAnyOrigin: Ideal para endpoints p√∫blicos, mas menos seguro.  
AllowFrontendAuth: Restringe acesso a origens confi√°veis, m√©todos e cabe√ßalhos, ideal para endpoints com autentica√ß√£o JWT.  
[EnableCors]: Aplica pol√≠ticas espec√≠ficas por controller ou endpoint.  
AllowCredentials com WithOrigins exige origens expl√≠citas (n√£o funciona com AllowAnyOrigin).


5. üîê Integra√ß√£o com Autentica√ß√£o
Para integrar com os resumos anteriores (ex.: autentica√ß√£o JWT de 14/04/2025, 2FA de 16/04/2025), ajuste o AuthController:
[ApiController]
[Route("api/auth")]
[EnableCors("AllowFrontendAuth")] // Aplica pol√≠tica autenticada
public class AuthController : ControllerBase
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly SignInManager<ApplicationUser> _signInManager;
    private readonly IConfiguration _configuration;

    public AuthController(
        UserManager<ApplicationUser> userManager,
        SignInManager<ApplicationUser> signInManager,
        IConfiguration configuration)
    {
        _userManager = userManager;
        _signInManager = signInManager;
        _configuration = configuration;
    }

    // Exemplo: Login com 2FA (do resumo anterior)
    [HttpPost("login-2fa")]
    [AllowAnonymous]
    public async Task<IActionResult> LoginWithTwoFactor(TwoFactorLoginDTO dto)
    {
        var user = await _userManager.FindByNameAsync(dto.UserName);
        if (user == null)
            return Unauthorized(new { Message = "Credenciais inv√°lidas." });

        var passwordSignIn = await _signInManager.CheckPasswordSignInAsync(user, dto.Password, false);
        if (!passwordSignIn.Succeeded)
            return Unauthorized(new { Message = "Credenciais inv√°lidas." });

        if (!await _userManager.GetTwoFactorEnabledAsync(user))
            return BadRequest(new { Message = "2FA n√£o est√° ativado." });

        var isValidCode = await _userManager.VerifyTwoFactorTokenAsync(
            user,
            _userManager.Options.Tokens.AuthenticatorTokenProvider,
            dto.TwoFactorCode
        );
        if (!isValidCode)
            return Unauthorized(new { Message = "C√≥digo 2FA inv√°lido." });

        var token = await GenerateJwtToken(user);
        return Ok(token);
    }

    // M√©todo GenerateJwtToken (reutilizado do resumo anterior)
    private async Task<RespuestaAutenticacionDTO> GenerateJwtToken(ApplicationUser user)
    {
        var claims = new List<Claim>
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.UserName),
            new Claim(JwtRegisteredClaimNames.Email, user.Email),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim("NomeCompleto", user.NomeCompleto),
            new Claim("Id", user.Id)
        };

        var userRoles = await _userManager.GetRolesAsync(user);
        claims.AddRange(userRoles.Select(role => new Claim(ClaimTypes.Role, role)));

        var key = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(_configuration["Jwt:Key"])
        );
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        var expiry = DateTime.UtcNow.AddMinutes(30);

        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"],
            audience: _configuration["Jwt:Audience"],
            claims: claims,
            expires: expiry,
            signingCredentials: creds
        );

        return new RespuestaAutenticacionDTO
        {
            Token = new JwtSecurityTokenHandler().WriteToken(token),
            Expiracion = expiry
        };
    }
}

Explica√ß√£o:  

[EnableCors("AllowFrontendAuth")]: Garante que endpoints como login-2fa sejam acess√≠veis apenas pelo frontend autorizado (ex.: http://localhost:4200).  
AllowCredentials: Permite enviar o cabe√ßalho Authorization com JWT.  
Integra com 2FA, login com Google, e envio de e-mails, mantendo consist√™ncia.


6. üõ†Ô∏è Solu√ß√£o de Problemas Comuns

Erro: "No 'Access-Control-Allow-Origin' header is present"  

Causa: O middleware CORS n√£o est√° configurado ou est√° ap√≥s UseRouting.  
Solu√ß√£o: Coloque app.UseCors() antes de app.UseAuthentication() e app.UseAuthorization():app.UseCors("AllowFrontend");
app.UseAuthentication();
app.UseAuthorization();




Erro: "Credentials flag is 'true', but the 'Access-Control-Allow-Credentials' header is not present"  

Causa: AllowCredentials() n√£o est√° na pol√≠tica, ou AllowAnyOrigin √© usado com credenciais.  
Solu√ß√£o: Use WithOrigins expl√≠citas e AllowCredentials:policy.WithOrigins("http://localhost:4200")
      .AllowCredentials();




Erro: "Method not allowed"  

Causa: A pol√≠tica restringe m√©todos (ex.: WithMethods("GET") n√£o inclui POST).  
Solu√ß√£o: Adicione m√©todos necess√°rios:policy.WithMethods("GET", "POST", "PUT");




Erro no Frontend Angular  

Causa: O frontend n√£o envia credenciais corretamente.  
Solu√ß√£o: Configure o HttpClient para incluir credenciais:// Angular: src/app/services/auth.service.ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  login2fa(credentials: any) {
    return this.http.post('https://localhost:5001/api/auth/login-2fa', credentials, {
      withCredentials: true // Envia credenciais
    });
  }
}






7. üìå Boas Pr√°ticas e Seguran√ßa

Restringir Origens: Use WithOrigins para listar apenas dom√≠nios confi√°veis (ex.: http://localhost:4200, https://meufrontend.com). Evite AllowAnyOrigin em produ√ß√£o.  
M√©todos Espec√≠ficos: Limite m√©todos com WithMethods para apenas os necess√°rios (ex.: GET, POST).  
Cabe√ßalhos Controlados: Use WithHeaders para permitir apenas cabe√ßalhos como Authorization e Content-Type.  
Credenciais Seguras: Combine AllowCredentials com HTTPS para proteger tokens JWT.  
Pr√©-requisitos (Preflight): O ASP.NET Core lida automaticamente com requisi√ß√µes OPTIONS; garanta que UseCors esteja no in√≠cio do pipeline.  
Logging: Registre erros de CORS para depura√ß√£o:app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        var exception = context.Features.Get<IExceptionHandlerFeature>();
        if (exception != null)
        {
            Console.WriteLine($"Erro CORS: {exception.Error.Message}");
            context.Response.StatusCode = 500;
            await context.Response.WriteAsync("Erro interno.");
        }
    });
});


Testes: Teste CORS com ferramentas como Postman ou cURL:curl -H "Origin: http://localhost:4200" \
     -H "Authorization: Bearer seu-token-jwt" \
     -X GET https://localhost:5001/api/protected/data


Produ√ß√£o: Atualize WithOrigins com o dom√≠nio real do frontend em produ√ß√£o.


8. üåü Exemplo de Frontend (Opcional)
Se voc√™ usa Angular (como mencionado em 13/03/2025), aqui est√° um exemplo de configura√ß√£o para consumir a API com CORS:
// Angular: src/app/services/auth.service.ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private apiUrl = 'https://localhost:5001/api/auth';

  constructor(private http: HttpClient) {}

  login2fa(credentials: { userName: string, password: string, twoFactorCode: string }): Observable<any> {
    return this.http.post(`${this.apiUrl}/login-2fa`, credentials, {
      withCredentials: true // Necess√°rio para CORS com credenciais
    });
  }

  getProtectedData(): Observable<any> {
    return this.http.get('https://localhost:5001/api/protected/data', {
      withCredentials: true
    });
  }
}

Explica√ß√£o:  

withCredentials: true: Garante que o Angular envie cabe√ßalhos como Authorization e cookies.  
Use o servi√ßo em componentes para chamar endpoints protegidos.


